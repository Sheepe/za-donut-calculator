import SolutionDonut from "./SolutionDonut"
import type {
    Berry,
    BerryType,
    DonutProfile,
    SavedDonut,
} from "../../donut_data"
import type { WorkerStats } from "../../solver/Solver"
import {
    Box,
    Button,
    Flex,
    Modal,
    ScrollArea,
    Space,
    Stack,
    Text,
    TextInput,
} from "@mantine/core"
import {
    Virtualizer,
    defaultRangeExtractor,
    elementScroll,
    measureElement as measureElementUtil,
    observeElementOffset,
    observeElementRect,
} from "@tanstack/virtual-core"
import {
    useCallback,
    useEffect,
    useLayoutEffect,
    useReducer,
    useRef,
    useState,
} from "react"
import { useDisclosure } from "@mantine/hooks"
import DisplayDonut from "./DisplayDonut"
import { type BerryStorage } from "../app/App"
import { notifications } from "@mantine/notifications"

type DonutData = [[BerryType, Berry, number][], DonutProfile]

// Most code below this point was generated by Chat GPT

type Props = {
    solutions: number[][]
    stats: WorkerStats | null
    getDonutFromSolution: (slots: number[]) => DonutData
    height?: number
    scrollbarSize?: number
    savedDonuts: SavedDonut[]
    setSavedDonuts: (v: SavedDonut[]) => void
    applyDonut: (berries: [BerryType, Berry, number][]) => void
    berryStorage: BerryStorage
}

const queueTask = (fn: () => void) => {
    if (typeof queueMicrotask === "function") queueMicrotask(fn)
    else Promise.resolve().then(fn)
}

type CoreOpts = {
    count: number
    getScrollElement: () => HTMLDivElement | null
    estimateSize: (index: number) => number
    getItemKey: (index: number) => string
    overscan?: number
    enabled?: boolean
}

const useVirtualizerCore = (opts: CoreOpts) => {
    const [, force] = useReducer((x: number) => x + 1, 0)

    const scheduledRef = useRef(false)
    const scheduleRerender = useCallback(() => {
        if (scheduledRef.current) return
        scheduledRef.current = true
        queueTask(() => {
            scheduledRef.current = false
            force()
        })
    }, [])

    const vRef = useRef<Virtualizer<HTMLDivElement, HTMLDivElement> | null>(
        null
    )

    const makeOptions = useCallback(() => {
        return {
            count: opts.count,
            enabled: opts.enabled ?? true,
            getScrollElement: opts.getScrollElement,
            estimateSize: opts.estimateSize,
            getItemKey: opts.getItemKey,
            overscan: opts.overscan ?? 4,

            scrollToFn: elementScroll,
            observeElementRect,
            observeElementOffset,

            rangeExtractor: defaultRangeExtractor,
            indexAttribute: "data-index" as const,
            measureElement: measureElementUtil,

            onChange: () => scheduleRerender(),
        }
    }, [
        opts.count,
        opts.enabled,
        opts.getScrollElement,
        opts.estimateSize,
        opts.getItemKey,
        opts.overscan,
        scheduleRerender,
    ])

    if (!vRef.current)
        vRef.current = new Virtualizer<HTMLDivElement, HTMLDivElement>(
            makeOptions()
        )

    useEffect(() => {
        const v = vRef.current
        if (!v) return
        return v._didMount()
    }, [])

    useLayoutEffect(() => {
        const v = vRef.current
        if (!v) return
        v.setOptions(makeOptions())
        v._willUpdate()
    }, [makeOptions])

    return vRef.current
}

export const SolutionDonutList = (props: Props) => {
    const {
        solutions,
        stats,
        getDonutFromSolution,
        height = 700,
        scrollbarSize = 10,
        savedDonuts,
        setSavedDonuts,
        applyDonut,
        berryStorage,
    } = props

    const count = solutions.length
    if (count === 0) return <Space h="md" />

    const [opened, { open, close }] = useDisclosure(false)

    const [viewportEl, setViewportEl] = useState<HTMLDivElement | null>(null)

    const keysRef = useRef<string[]>([])
    const donutCacheRef = useRef<Map<string, DonutData>>(new Map())

    useEffect(() => {
        const nextKeys = new Array<string>(solutions.length)
        for (let i = 0; i < solutions.length; i++)
            nextKeys[i] = solutions[i].join(",")
        keysRef.current = nextKeys

        if (solutions.length === 0) donutCacheRef.current.clear()
    }, [solutions])

    const setViewportRef = useCallback((node: HTMLDivElement | null) => {
        setViewportEl(node)
    }, [])

    const getScrollElement = useCallback(() => viewportEl, [viewportEl])
    const estimateSize = useCallback((_: number) => 320, [])

    const getItemKey = useCallback((index: number) => {
        const k = keysRef.current[index]
        return typeof k === "string" ? k : String(index)
    }, [])

    const enabled = viewportEl !== null

    const virtualizer = useVirtualizerCore({
        count,
        enabled,
        getScrollElement,
        estimateSize,
        getItemKey,
        overscan: 4,
    })

    const getDonutCached = (key: string, slots: number[]) => {
        const m = donutCacheRef.current
        const hit = m.get(key)
        if (hit) return hit
        const val = getDonutFromSolution(slots)
        m.set(key, val)
        return val
    }

    const virtualItems = enabled ? virtualizer.getVirtualItems() : []
    const totalSize = enabled ? virtualizer.getTotalSize() : 0

    const fallbackN = Math.min(8, count)
    const fallbackIdxs = new Array<number>(fallbackN)
    for (let i = 0; i < fallbackN; i++) fallbackIdxs[i] = i

    const shouldFallback = !enabled || virtualItems.length === 0

    const maxH = height
    const contentH = shouldFallback
        ? undefined
        : Math.max(1, Math.ceil(totalSize))
    const scrollH = contentH ? Math.min(maxH, contentH) : undefined

    const [saveDonutName, setSaveDonutName] = useState("")
    const [saveDonutBerries, setSaveDonutBerries] = useState<
        [BerryType, Berry, number][]
    >([])
    const [saveDonutProfile, setSaveDonutProfile] = useState<DonutProfile>([
        0, 0, 0, 0, 0,
    ])
    const [donutNameError, setDonutNameError] = useState("")

    return (
        <>
            <Modal opened={opened} onClose={close} title="Save Donut" centered>
                <Flex direction="column" align="center">
                    <DisplayDonut
                        name={
                            saveDonutName.length === 0
                                ? "Your Awesome Donut"
                                : saveDonutName
                        }
                        berries={saveDonutBerries}
                        profile={saveDonutProfile}
                        controls={false}
                        applyDonut={() => {}}
                        berryStorage={{ normal: {}, hyper: {} }}
						savedDonuts={savedDonuts}
						setSavedDonuts={setSavedDonuts}
						id={-1}
                    />
                    <TextInput
                        label={
                            <Text
                                // c={theme.colors.app[0]}
                                size="sm"
                                fw={650}
                                component="span"
                            >
                                Donut Name
                            </Text>
                        }
                        placeholder={"Your Awesome Donut"}
                        px="lg"
                        w="100%"
                        radius="xl"
                        withAsterisk
                        value={saveDonutName}
                        error={donutNameError}
                        onChange={(v) => {
                            setSaveDonutName(v.currentTarget.value)
                            setDonutNameError("")
                        }}
                    />
                    <Button
                        color="green"
                        size="md"
                        maw="200px"
                        radius="md"
                        mt="lg"
                        onClick={() => {
                            if (saveDonutName.length === 0) {
                                setDonutNameError("A name must be provided")
                                return
                            }
                            notifications.show({
                                title: "Donut Saved",
                                color: "green",
                                message: `"${saveDonutName}" has been saved`,
                                autoClose: 2000,
                                withCloseButton: true,
                            })
                            setSavedDonuts(
                                savedDonuts.concat([
                                    {
                                        name: saveDonutName,
                                        berries: saveDonutBerries,
                                        profile: saveDonutProfile,
                                    },
                                ])
                            )
                            close()
                        }}
                    >
                        Save
                    </Button>
                </Flex>
            </Modal>
            <ScrollArea
                h={scrollH}
                mah={maxH}
                viewportRef={setViewportRef}
                my="md"
                type="never"
                scrollbarSize={scrollbarSize}
                w="350px"
                style={{ overflow: "visible" }}
            >
                {shouldFallback ? (
                    <Stack gap={0}>
                        {fallbackIdxs.map((i) => {
                            const slots = solutions[i]
                            const key = keysRef.current[i] ?? slots.join(",")
                            const donut = getDonutCached(key, slots)

                            return (
                                <Box
                                    key={key}
                                    style={{ paddingBottom: "0.75em" }}
                                >
                                    <SolutionDonut
                                        profile={donut[1]}
                                        berries={donut[0]}
                                        optimal={!!stats?.isOptimal && i === 0}
                                        onSave={() => {
                                            setSaveDonutName("")
                                            setSaveDonutBerries(donut[0])
                                            setSaveDonutProfile(donut[1])
                                            open()
                                        }}
                                        berryStorage={berryStorage}
                                        applyDonut={applyDonut}
                                    />
                                </Box>
                            )
                        })}
                    </Stack>
                ) : (
                    <Box style={{ height: totalSize, position: "relative" }}>
                        {virtualItems.map((v) => {
                            const slots = solutions[v.index]
                            if (!slots) return null

                            const key = String(v.key)
                            const donut = getDonutCached(key, slots)

                            return (
                                <Box
                                    key={key}
                                    data-index={v.index}
                                    ref={(el) => virtualizer.measureElement(el)}
                                    style={{
                                        position: "absolute",
                                        top: 0,
                                        left: 0,
                                        width: "100%",
                                        transform: `translateY(${v.start}px)`,
                                        paddingTop: "0.75em",
                                        paddingLeft: "0.75em",
                                        paddingRight: "0.75em",
                                    }}
                                >
                                    <SolutionDonut
                                        profile={donut[1]}
                                        berries={donut[0]}
                                        optimal={
                                            !!stats?.isOptimal && v.index === 0
                                        }
                                        onSave={() => {
                                            setSaveDonutName("")
                                            setSaveDonutBerries(donut[0])
                                            setSaveDonutProfile(donut[1])
                                            open()
                                        }}
                                        berryStorage={berryStorage}
                                        applyDonut={applyDonut}
                                    />
                                </Box>
                            )
                        })}
                    </Box>
                )}
            </ScrollArea>
        </>
    )
}

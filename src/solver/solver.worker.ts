/// <reference lib="webworker" />
// All code in this file was generated by ChatGPT

const I_REAL = 66
const I_DUMMY = 67
const MAX_COMPONENT = 95

export interface Goal {
	mode: "ignore" | "min" | "max" | "exact" | "approx",
	weight?: number
	target?: number
}

export type SolveBatchConfig = {
	vectors: number[][]
	Kmin: number
	Kmax: number
	inventoryEnabled: boolean
	inventoryCaps?: number[]
	goals: Goal[]
	batchSize: number
	favorFewerVectors?: number
	options?: {
		timeout?: number
		sliceMs?: number
		maxNodes?: number
		greedyPerSlice?: number
		maxHeapSize?: number
	}
}

type Stats = {
	expanded: number
	generated: number
	heapSize: number
	maxDepth: number
	solutionsFound: number

	rate: number

	bestBound: number
	bestFound: number
	gap: number

	proofValid: boolean
	isOptimal: boolean

	heapCap: number
	droppedThisSlice: number
	droppedTotal: number
}

type BatchResult = {
	type: "batchResult"
	reqId?: number
	results: number[][]
	status: "ok" | "working" | "timedout" | "exhausted" | "cancelled"
	stats: Stats
	error?: string
}

type Node = {
	parent: Node | null
	pickId: number
	depth: number
	lastId: number
	t0: number
	t1: number
	t2: number
	t3: number
	t4: number
	used: number
	dummy: number
	invIds: number[] | null
	invCounts: number[] | null
	priority: number
}

const clamp01 = (x: number) => (x < 0 ? 0 : x > 1 ? 1 : x)
const weightOf = (g: any) => (typeof g?.weight === "number" ? g.weight : 1)

const makeCfgKey = (cfg: SolveBatchConfig) => {
	const caps = cfg.inventoryEnabled ? (cfg.inventoryCaps || []).join(",") : ""
	const favor = typeof cfg.favorFewerVectors === "number" ? cfg.favorFewerVectors : 0
	const heapKey =
		cfg.options?.maxHeapSize === Infinity ? "Infinity" :
		typeof cfg.options?.maxHeapSize === "number" ? cfg.options.maxHeapSize :
		"unset"

	return JSON.stringify({
		Kmin: cfg.Kmin,
		Kmax: cfg.Kmax,
		inv: cfg.inventoryEnabled,
		caps,
		goals: cfg.goals,
		favor,
		heapKey
	})
}

const compileGoals = (goals: Goal[]) => {
	const mode = new Int8Array(5)
	const w = new Float64Array(5)
	const t = new Int32Array(5)
	let hasExact = false

	for (let j = 0; j < 5; j++) {
		const g = goals[j]
		if (!g) {
			mode[j] = 0
			w[j] = 1
			t[j] = 0
			continue
		}

		w[j] = weightOf(g)

		if (g.mode === "ignore") mode[j] = 0
		else if (g.mode === "min") mode[j] = 1
		else if (g.mode === "max") mode[j] = 2
		else if (g.mode === "exact") {
			mode[j] = 3
			t[j] = (g.target ?? 0) | 0
			hasExact = true
		} else {
			mode[j] = 4
			t[j] = (g.target ?? 0) | 0
		}
	}

	return { mode, w, t, hasExact }
}

const computeMaxAdd = (vectors: number[][]) => {
	const maxAdd = [0, 0, 0, 0, 0]
	for (let i = 0; i < I_REAL; i++) {
		const v = vectors[i]
		for (let j = 0; j < 5; j++) {
			const a = v[j] | 0
			if (a > maxAdd[j]) maxAdd[j] = a
		}
	}
	return maxAdd
}

const fitUpperBound = (Kmax: number, mode: Int8Array, w: Float64Array, t: Int32Array) => {
	const yUpper = Kmax * MAX_COMPONENT
	let ub = 0

	for (let j = 0; j < 5; j++) {
		const m = mode[j]
		if (m === 3) continue

		const ww = w[j]

		if (m === 1 || m === 0) ub += ww * yUpper
		else if (m === 2) ub += ww * yUpper
		else {
			const target = t[j]
			const worst = Math.max(Math.abs(target - 0), Math.abs(target - yUpper))
			ub += ww * worst
		}
	}

	return ub > 0 ? ub : 1
}

const usedNorm = (Kmin: number, Kmax: number, used: number) => {
	const denom = Kmax - Kmin
	if (denom <= 0) return 0
	const x = (used - Kmin) / denom
	return x < 0 ? 0 : x > 1 ? 1 : x
}

const exactFeasible = (
	mode: Int8Array,
	t: Int32Array,
	cur0: number,
	cur1: number,
	cur2: number,
	cur3: number,
	cur4: number,
	remainingReal: number,
	maxAdd: number[]
) => {
	for (let j = 0; j < 5; j++) {
		if (mode[j] !== 3) continue

		const cur =
			j === 0 ? cur0 :
			j === 1 ? cur1 :
			j === 2 ? cur2 :
			j === 3 ? cur3 :
			cur4

		const target = t[j]
		if (cur > target) return false

		const maxReach = cur + remainingReal * maxAdd[j]
		if (maxReach < target) return false
	}

	return true
}

const fitLowerBound = (
	Kmax: number,
	mode: Int8Array,
	w: Float64Array,
	t: Int32Array,
	maxAdd: number[],
	cur0: number,
	cur1: number,
	cur2: number,
	cur3: number,
	cur4: number,
	remainingReal: number
) => {
	const yUpper = Kmax * MAX_COMPONENT
	let p = 0

	for (let j = 0; j < 5; j++) {
		const m = mode[j]
		if (m === 0 || m === 3) continue

		const ww = w[j]
		const cur =
			j === 0 ? cur0 :
			j === 1 ? cur1 :
			j === 2 ? cur2 :
			j === 3 ? cur3 :
			cur4

		if (m === 1) {
			p += ww * cur
			continue
		}

		if (m === 2) {
			const maxReach = cur + remainingReal * maxAdd[j]
			const best = maxReach > yUpper ? yUpper : maxReach
			const lb = yUpper - best
			p += ww * (lb > 0 ? lb : 0)
			continue
		}

		const lo = cur
		const hi = cur + remainingReal * maxAdd[j]
		const target = t[j]

		let d = 0
		if (target < lo) d = lo - target
		else if (target > hi) d = target - hi
		p += ww * d
	}

	return p
}

const fitExact = (
	Kmax: number,
	mode: Int8Array,
	w: Float64Array,
	t: Int32Array,
	cur0: number,
	cur1: number,
	cur2: number,
	cur3: number,
	cur4: number
) => {
	const yUpper = Kmax * MAX_COMPONENT
	let p = 0

	for (let j = 0; j < 5; j++) {
		const m = mode[j]
		const cur =
			j === 0 ? cur0 :
			j === 1 ? cur1 :
			j === 2 ? cur2 :
			j === 3 ? cur3 :
			cur4

		if (m === 3) {
			if (cur !== t[j]) return Number.POSITIVE_INFINITY
			continue
		}

		if (m === 0) continue

		const ww = w[j]
		if (m === 1) p += ww * cur
		else if (m === 2) p += ww * (yUpper - cur)
		else p += ww * Math.abs(cur - t[j])
	}

	return p
}

class MinHeap {
	private a: Node[]
	constructor() {
		this.a = []
	}

	size() {
		return this.a.length
	}

	peek() {
		return this.a.length ? this.a[0] : null
	}

	private less(i: number, j: number) {
		const ai = this.a[i]
		const aj = this.a[j]
		if (ai.priority !== aj.priority) return ai.priority < aj.priority
		return ai.depth > aj.depth
	}

	push(x: Node) {
		const a = this.a
		a.push(x)

		let i = a.length - 1
		while (i > 0) {
			const p = (i - 1) >> 1
			if (!this.less(i, p)) break
			const tmp = a[i]
			a[i] = a[p]
			a[p] = tmp
			i = p
		}
	}

	pop() {
		const a = this.a
		if (a.length === 0) return null

		const top = a[0]
		const last = a.pop()
		if (a.length > 0 && last) {
			a[0] = last

			let i = 0
			for (;;) {
				const l = i * 2 + 1
				const r = l + 1
				let m = i

				if (l < a.length && this.less(l, m)) m = l
				if (r < a.length && this.less(r, m)) m = r
				if (m === i) break

				const tmp = a[i]
				a[i] = a[m]
				a[m] = tmp
				i = m
			}
		}

		return top
	}
}

const invCanAdd = (invCaps: number[], ids: number[], counts: number[], id: number) => {
	for (let i = 0; i < ids.length; i++) {
		if (ids[i] === id) {
			const next = counts[i] + 1
			if (next > invCaps[id - 1]) return null

			const nIds = ids.slice()
			const nCounts = counts.slice()
			nCounts[i] = next
			return { nIds, nCounts }
		}
	}

	if (1 > invCaps[id - 1]) return null

	const nIds = ids.slice()
	const nCounts = counts.slice()
	nIds.push(id)
	nCounts.push(1)
	return { nIds, nCounts }
}

const reconstructSlots = (leaf: Node, Kmax: number) => {
	const out = new Array<number>(Kmax)
	let cur: Node | null = leaf
	let idx = Kmax - 1

	while (cur && cur.depth > 0) {
		out[idx] = cur.pickId
		idx -= 1
		cur = cur.parent
	}

	while (idx >= 0) {
		out[idx] = I_DUMMY
		idx -= 1
	}

	return out
}

let cancelled = false

let engineKey = ""
let heap = new MinHeap()
let excluded = new Set<string>()

let vectors: number[][] = []
let Kmin = 3
let Kmax = 8
let dummyLimit = 5

let invEnabled = false
let invCaps: number[] | null = null
let favor = 0

let goalMode = new Int8Array(5)
let goalW = new Float64Array(5)
let goalT = new Int32Array(5)
let hasExact = false

let maxAdd = [0, 0, 0, 0, 0]
let fitUb = 1

let expandedTotal = 0
let generatedTotal = 0
let maxDepthSeen = 0
let solutionsFoundTotal = 0

let bestFound = Number.POSITIVE_INFINITY

let heapCap = Infinity
let droppedThisSlice = 0
let droppedTotal = 0

let lastSliceExpanded = 0
let lastSliceMs = 1

const resetEngine = (cfg: SolveBatchConfig) => {
	engineKey = makeCfgKey(cfg)

	vectors = cfg.vectors
	Kmin = cfg.Kmin
	Kmax = cfg.Kmax
	dummyLimit = Kmax - Kmin

	invEnabled = !!cfg.inventoryEnabled
	invCaps = invEnabled ? (cfg.inventoryCaps || null) : null

	favor = clamp01(typeof cfg.favorFewerVectors === "number" ? cfg.favorFewerVectors : 0)

	const g = compileGoals(cfg.goals)
	goalMode = g.mode
	goalW = g.w
	goalT = g.t
	hasExact = g.hasExact

	maxAdd = computeMaxAdd(vectors)
	fitUb = fitUpperBound(Kmax, goalMode, goalW, goalT)

	const optCap = cfg.options?.maxHeapSize
	heapCap = optCap === Infinity ? Infinity : (typeof optCap === "number" ? optCap : Infinity)

	heap = new MinHeap()
	excluded = new Set<string>()

	expandedTotal = 0
	generatedTotal = 0
	maxDepthSeen = 0
	solutionsFoundTotal = 0
	bestFound = Number.POSITIVE_INFINITY

	droppedThisSlice = 0
	droppedTotal = 0

	lastSliceExpanded = 0
	lastSliceMs = 1

	const root: Node = {
		parent: null,
		pickId: 0,
		depth: 0,
		lastId: 1,
		t0: 0, t1: 0, t2: 0, t3: 0, t4: 0,
		used: 0,
		dummy: 0,
		invIds: invEnabled ? [] : null,
		invCounts: invEnabled ? [] : null,
		priority: 0
	}

	root.priority = 0
	heap.push(root)
}

const objectiveLowerBound = (st: Node) => {
	const remainingReal = st.lastId === I_DUMMY ? 0 : (Kmax - st.depth)

	const lbFit = fitLowerBound(
		Kmax, goalMode, goalW, goalT, maxAdd,
		st.t0, st.t1, st.t2, st.t3, st.t4,
		remainingReal
	)

	const lbFitNorm = lbFit / fitUb

	const usedLB = st.used < Kmin ? Kmin : st.used
	const lbUsedNorm = usedNorm(Kmin, Kmax, usedLB)

	return (1 - favor) * lbFitNorm + favor * lbUsedNorm
}

const objectiveExact = (st: Node) => {
	const fit = fitExact(Kmax, goalMode, goalW, goalT, st.t0, st.t1, st.t2, st.t3, st.t4)
	const fitNorm = fit / fitUb
	const uNorm = usedNorm(Kmin, Kmax, st.used)
	return (1 - favor) * fitNorm + favor * uNorm
}

const canPushMore = () => heap.size() < heapCap

const pushChild = (child: Node) => {
	if (!canPushMore()) {
		droppedThisSlice += 1
		droppedTotal += 1
		return
	}

	child.priority = objectiveLowerBound(child)
	heap.push(child)
	generatedTotal += 1
}

const expand = (st: Node) => {
	if (st.lastId === I_DUMMY) {
		const child: Node = {
			parent: st,
			pickId: I_DUMMY,
			depth: st.depth + 1,
			lastId: I_DUMMY,
			t0: st.t0, t1: st.t1, t2: st.t2, t3: st.t3, t4: st.t4,
			used: st.used,
			dummy: st.dummy + 1,
			invIds: st.invIds,
			invCounts: st.invCounts,
			priority: 0
		}

		if (child.dummy <= dummyLimit) pushChild(child)
		return
	}

	const remainingAfter = Kmax - (st.depth + 1)

	for (let id = st.lastId; id <= I_DUMMY; id++) {
		const nextDummy = id === I_DUMMY ? st.dummy + 1 : st.dummy
		if (nextDummy > dummyLimit) continue

		let nt0 = st.t0
		let nt1 = st.t1
		let nt2 = st.t2
		let nt3 = st.t3
		let nt4 = st.t4
		let nused = st.used

		let nInvIds = st.invIds
		let nInvCounts = st.invCounts

		if (id !== I_DUMMY) {
			const v = vectors[id - 1]
			nt0 += v[0]
			nt1 += v[1]
			nt2 += v[2]
			nt3 += v[3]
			nt4 += v[4]
			nused += 1

			if (invEnabled) {
				if (!invCaps) continue
				if (!st.invIds || !st.invCounts) continue
				const upd = invCanAdd(invCaps, st.invIds, st.invCounts, id)
				if (!upd) continue
				nInvIds = upd.nIds
				nInvCounts = upd.nCounts
			}
		}

		if (hasExact) {
			const remReal = id === I_DUMMY ? 0 : remainingAfter
			if (!exactFeasible(goalMode, goalT, nt0, nt1, nt2, nt3, nt4, remReal, maxAdd)) continue
		}

		const child: Node = {
			parent: st,
			pickId: id,
			depth: st.depth + 1,
			lastId: id,
			t0: nt0, t1: nt1, t2: nt2, t3: nt3, t4: nt4,
			used: nused,
			dummy: nextDummy,
			invIds: nInvIds,
			invCounts: nInvCounts,
			priority: 0
		}

		pushChild(child)
	}
}

const greedyComplete = (start: Node) => {
	let cur = start

	while (cur.depth < Kmax) {
		if (cur.lastId === I_DUMMY) {
			const next: Node = {
				parent: cur,
				pickId: I_DUMMY,
				depth: cur.depth + 1,
				lastId: I_DUMMY,
				t0: cur.t0, t1: cur.t1, t2: cur.t2, t3: cur.t3, t4: cur.t4,
				used: cur.used,
				dummy: cur.dummy + 1,
				invIds: cur.invIds,
				invCounts: cur.invCounts,
				priority: 0
			}
			if (next.dummy > dummyLimit) return null
			cur = next
			continue
		}

		let best: Node | null = null
		let bestScore = Number.POSITIVE_INFINITY

		const remainingAfter = Kmax - (cur.depth + 1)

		for (let id = cur.lastId; id <= I_DUMMY; id++) {
			const nextDummy = id === I_DUMMY ? cur.dummy + 1 : cur.dummy
			if (nextDummy > dummyLimit) continue

			let nt0 = cur.t0
			let nt1 = cur.t1
			let nt2 = cur.t2
			let nt3 = cur.t3
			let nt4 = cur.t4
			let nused = cur.used

			let nInvIds = cur.invIds
			let nInvCounts = cur.invCounts

			if (id !== I_DUMMY) {
				const v = vectors[id - 1]
				nt0 += v[0]
				nt1 += v[1]
				nt2 += v[2]
				nt3 += v[3]
				nt4 += v[4]
				nused += 1

				if (invEnabled) {
					if (!invCaps) continue
					if (!cur.invIds || !cur.invCounts) continue
					const upd = invCanAdd(invCaps, cur.invIds, cur.invCounts, id)
					if (!upd) continue
					nInvIds = upd.nIds
					nInvCounts = upd.nCounts
				}
			}

			if (hasExact) {
				const remReal = id === I_DUMMY ? 0 : remainingAfter
				if (!exactFeasible(goalMode, goalT, nt0, nt1, nt2, nt3, nt4, remReal, maxAdd)) continue
			}

			const cand: Node = {
				parent: cur,
				pickId: id,
				depth: cur.depth + 1,
				lastId: id,
				t0: nt0, t1: nt1, t2: nt2, t3: nt3, t4: nt4,
				used: nused,
				dummy: nextDummy,
				invIds: nInvIds,
				invCounts: nInvCounts,
				priority: 0
			}

			const score = objectiveLowerBound(cand)
			if (score < bestScore) {
				bestScore = score
				best = cand
			}
		}

		if (!best) return null
		cur = best
	}

	if (cur.used < Kmin) return null
	if (!Number.isFinite(fitExact(Kmax, goalMode, goalW, goalT, cur.t0, cur.t1, cur.t2, cur.t3, cur.t4))) return null

	return cur
}

const buildStats = (): Stats => {
	const eps = 1e-12
	const rate = lastSliceMs > 0 ? (lastSliceExpanded / (lastSliceMs / 1000)) : 0

	const proofValid = droppedTotal === 0
	const peek = heap.peek()

	if (!peek) {
		if (Number.isFinite(bestFound) && proofValid) {
			return {
				expanded: expandedTotal,
				generated: generatedTotal,
				heapSize: heap.size(),
				maxDepth: maxDepthSeen,
				solutionsFound: solutionsFoundTotal,
				rate: Number.isFinite(rate) ? rate : 0,
				bestBound: bestFound,
				bestFound,
				gap: 0,
				proofValid,
				isOptimal: true,
				heapCap,
				droppedThisSlice,
				droppedTotal
			}
		}

		return {
			expanded: expandedTotal,
			generated: generatedTotal,
			heapSize: heap.size(),
			maxDepth: maxDepthSeen,
			solutionsFound: solutionsFoundTotal,
			rate: Number.isFinite(rate) ? rate : 0,
			bestBound: Number.POSITIVE_INFINITY,
			bestFound,
			gap: Number.POSITIVE_INFINITY,
			proofValid,
			isOptimal: false,
			heapCap,
			droppedThisSlice,
			droppedTotal
		}
	}

	const bestBound = peek.priority

	let gap = Number.POSITIVE_INFINITY
	if (Number.isFinite(bestFound) && Number.isFinite(bestBound)) {
		gap = Math.max(0, bestFound - bestBound)
	}

	const isOptimal =
		proofValid &&
		Number.isFinite(bestFound) &&
		Number.isFinite(bestBound) &&
		bestBound >= bestFound - eps

	return {
		expanded: expandedTotal,
		generated: generatedTotal,
		heapSize: heap.size(),
		maxDepth: maxDepthSeen,
		solutionsFound: solutionsFoundTotal,
		rate: Number.isFinite(rate) ? rate : 0,
		bestBound,
		bestFound,
		gap,
		proofValid,
		isOptimal,
		heapCap,
		droppedThisSlice,
		droppedTotal
	}
}

const post = (payload: BatchResult) => {
	;(self as any).postMessage(payload)
}

self.onmessage = (ev: MessageEvent<any>) => {
	try {
		const msg = ev.data

		if (msg && msg.type === "cancel") {
			cancelled = true
			return
		}

		if (msg && msg.type === "reset") {
			cancelled = true
			engineKey = ""
			heap = new MinHeap()
			excluded = new Set<string>()
			bestFound = Number.POSITIVE_INFINITY
			droppedThisSlice = 0
			droppedTotal = 0
			heapCap = Infinity
			return
		}

		if (!msg || msg.type !== "solveBatch") return

		cancelled = false

		const reqId = msg.reqId as number | undefined
		const cfg = msg.config as SolveBatchConfig

		const key = makeCfgKey(cfg)
		if (key !== engineKey) resetEngine(cfg)

		droppedThisSlice = 0

		const timeout = cfg.options?.timeout
		const infinite = timeout === Infinity

		const sliceMs = typeof cfg.options?.sliceMs === "number" ? cfg.options.sliceMs : 25
		const deadline = Date.now() + (infinite ? sliceMs : (typeof timeout === "number" ? timeout : 50))

		const maxNodes = typeof cfg.options?.maxNodes === "number" ? cfg.options.maxNodes : 200000
		const greedyPerSlice = typeof cfg.options?.greedyPerSlice === "number" ? cfg.options.greedyPerSlice : 2

		const results: number[][] = []

		const sliceStart = performance.now()
		const expandedAtStart = expandedTotal
		let nodesThisCall = 0

		const finalize = (status: BatchResult["status"]) => {
			lastSliceExpanded = expandedTotal - expandedAtStart
			lastSliceMs = Math.max(1, performance.now() - sliceStart)

			post({
				type: "batchResult",
				reqId,
				results,
				status,
				stats: buildStats()
			})
		}

		if (cancelled) {
			finalize("cancelled")
			return
		}

		if (results.length === 0 && greedyPerSlice > 0) {
			let tries = 0
			while (tries < greedyPerSlice) {
				if (cancelled) {
					finalize("cancelled")
					return
				}

				const peek = heap.peek()
				if (!peek) break

				const leaf = greedyComplete(peek)
				if (leaf) {
					const slots = reconstructSlots(leaf, Kmax)
					const key2 = slots.join(",")

					if (!excluded.has(key2)) {
						excluded.add(key2)

						const obj = objectiveExact(leaf)
						if (obj < bestFound) bestFound = obj

						results.push(slots)
						solutionsFoundTotal += 1
						break
					}
				}

				tries += 1
			}

			if (results.length >= cfg.batchSize) {
				finalize("ok")
				return
			}
		}

		while (true) {
			if (cancelled) {
				finalize("cancelled")
				return
			}

			if (heap.size() === 0) {
				finalize("exhausted")
				return
			}

			const timeUp = Date.now() > deadline
			const nodeUp = nodesThisCall >= maxNodes

			if (timeUp || nodeUp) {
				let status: BatchResult["status"]

				if (results.length > 0) {
					status = "ok"
				} else if (!infinite && timeUp) {
					status = "timedout"
				} else {
					status = "working"
				}

				finalize(status)
				return
			}

			const st = heap.pop()
			if (!st) continue

			nodesThisCall += 1
			expandedTotal += 1
			if (st.depth > maxDepthSeen) maxDepthSeen = st.depth

			if (st.depth === Kmax) {
				if (st.used < Kmin) continue

				const hard = fitExact(Kmax, goalMode, goalW, goalT, st.t0, st.t1, st.t2, st.t3, st.t4)
				if (!Number.isFinite(hard)) continue

				const slots = reconstructSlots(st, Kmax)
				const key2 = slots.join(",")

				if (excluded.has(key2)) continue
				excluded.add(key2)

				const obj = objectiveExact(st)
				if (obj < bestFound) bestFound = obj

				results.push(slots)
				solutionsFoundTotal += 1

				if (results.length >= cfg.batchSize) {
					finalize("ok")
					return
				}

				continue
			}

			expand(st)
		}
	} catch (e: any) {
		post({
			type: "batchResult",
			reqId: ev.data?.reqId,
			results: [],
			status: "timedout",
			stats: {
				expanded: 0,
				generated: 0,
				heapSize: 0,
				maxDepth: 0,
				solutionsFound: 0,
				rate: 0,
				bestBound: Number.POSITIVE_INFINITY,
				bestFound: Number.POSITIVE_INFINITY,
				gap: Number.POSITIVE_INFINITY,
				proofValid: true,
				isOptimal: false,
				heapCap: Infinity,
				droppedThisSlice: 0,
				droppedTotal: 0
			},
			error: String(e?.message || e)
		})
	}
}

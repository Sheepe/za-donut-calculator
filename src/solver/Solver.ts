import { BERRY_DATA, type Berry, type BerryType, type DonutProfile } from "../donut_data"
import type { Goal } from "./solver.worker"
import { useEffect, useRef, useState } from "react"

function createVectorSolverWorker() {
	return new Worker(new URL("./solver.worker.ts", import.meta.url), { type: "module" })
}

const berryVectors: number[][] = []
const berryIndex: [keyof typeof BERRY_DATA, Berry][] = []

for (const berry in BERRY_DATA.normal) {
	berryVectors.push(BERRY_DATA.normal[berry as Berry].vector.slice(0, 5))
	berryIndex.push(["normal", berry as Berry])
}

for (const berry in BERRY_DATA.hyper) {
	berryVectors.push(BERRY_DATA.hyper[berry as Berry].vector.slice(0, 5))
	berryIndex.push(["hyper", berry as Berry])
}

export const getDonutFromSolution = (berries: number[]): [[BerryType, Berry, number][], DonutProfile] => {
	const berryList: [BerryType, Berry, number][] = []
	const profile: DonutProfile = [0, 0, 0, 0, 0]

	outer: for (let i = 0; i < berries.length; i++) {
		if (berries[i] === 67) continue
		const berry = berryIndex[berries[i] - 1]
		for (let j = 0; j < berryList.length; j++) {
			const old = berryList[j]
			if (old[0] === berry[0] && old[1] === berry[1]) {
				berryList[j][2] += 1

				const vector = BERRY_DATA[berry[0]][berry[1]].vector

				for (let j = 0; j < profile.length; j++) {
					profile[j] = profile[j] + vector[j]
				}

				continue outer
			}
		}
		berryList.push([...berry, 1])
		const vector = BERRY_DATA[berry[0]][berry[1]].vector

		for (let j = 0; j < profile.length; j++) {
			profile[j] = profile[j] + vector[j]
		}
	}

	berryList.sort((a, b) => {
		if (a[0] === "normal" && b[0] === "hyper") {
			return -1
		}
		if (a[0] === "hyper" && b[0] === "normal") {
			return 1
		}
		return 0
	})

	return [berryList, profile]
}

// All code below this point was generated by ChatGPT.

let nextReqId = 1

export type WorkerStats = {
	expanded: number
	generated: number
	heapSize: number
	maxDepth: number
	solutionsFound: number

	rate: number

	bestBound: number
	bestFound: number
	gap: number

	proofValid: boolean
	isOptimal: boolean

	heapCap: number
	droppedThisSlice: number
	droppedTotal: number
}

export const isProvablyOptimal = (s: WorkerStats | null, eps = 1e-12) => {
	if (!s) return false
	if (!Number.isFinite(s.bestFound)) return false
	if (!Number.isFinite(s.bestBound)) return false
	return s.bestBound >= s.bestFound - eps
}

export type SolveBatchReply = {
	results: number[][]
	status: "ok" | "working" | "timedout" | "exhausted" | "cancelled"
	stats: WorkerStats | null
}

export const solveBatch = (
	worker: Worker,
	config: any,
	signal: AbortSignal,
	hardTimeoutMs = 10000
) => {
	const reqId = nextReqId
	nextReqId += 1

	return new Promise<SolveBatchReply>((resolve, reject) => {
		let done = false

		const cleanup = () => {
			if (done) return
			done = true
			clearTimeout(timer)
			worker.removeEventListener("message", handler)
			signal.removeEventListener("abort", onAbort)
		}

		const onAbort = () => {
			cleanup()
			reject(new DOMException("Aborted", "AbortError"))
		}

		const handler = (ev: MessageEvent<any>) => {
			const data = ev.data
			if (!data || data.type !== "batchResult") return
			if (data.reqId !== reqId) return

			cleanup()

			if (data.error) {
				reject(new Error(String(data.error)))
				return
			}

			resolve({
				results: data.results || [],
				status: data.status || "ok",
				stats: data.stats || null
			})
		}

		const timer = window.setTimeout(() => {
			cleanup()
			reject(new Error("solveBatch hard timeout (worker did not reply)"))
		}, hardTimeoutMs)

		signal.addEventListener("abort", onAbort, { once: true })
		worker.addEventListener("message", handler)
		worker.postMessage({ type: "solveBatch", reqId, config })
	})
}

type Inputs = {
	maxBerries: number
	inventoryEnabled: boolean
	inventoryCaps?: number[]
	goals: Goal[]
	maxTimeout: number // ms or Infinity (time since last NEW solution)
	favorFewerVectors: number // 0..1 (solver + ranking)
	maxHeapSize?: number // number or Infinity
	sliceMs?: number
	maxNodes?: number
	greedyPerSlice?: number
}

const KMIN = 3
const I_DUMMY = 67
const MAX_COMPONENT = 95

const clamp01 = (x: number) => (x < 0 ? 0 : x > 1 ? 1 : x)

const countUsed = (slots: number[]) => {
	let used = 0
	for (let i = 0; i < slots.length; i++) {
		if (slots[i] !== I_DUMMY) used += 1
	}
	return used
}

const computeTotals = (slots: number[], Kmax: number) => {
	const y = [0, 0, 0, 0, 0]

	for (let k = 0; k < Kmax; k++) {
		const idx = slots[k]
		if (idx >= 1 && idx <= 66) {
			const v = berryVectors[idx - 1]
			y[0] += v[0]
			y[1] += v[1]
			y[2] += v[2]
			y[3] += v[3]
			y[4] += v[4]
		}
	}

	return y
}

const weightOf = (g: any) => (typeof g?.weight === "number" ? g.weight : 1)

const fitUpperBound = (frozen: Inputs) => {
	const yUpper = frozen.maxBerries * MAX_COMPONENT
	let ub = 0

	for (let j = 0; j < 5; j++) {
		const g = frozen.goals[j]
		if (!g || g.mode === "exact") continue

		const w = weightOf(g)

		if (g.mode === "min" || g.mode === "ignore") ub += w * yUpper
		else if (g.mode === "max") ub += w * yUpper
		else if (g.mode === "approx") {
			const t = (g.target ?? 0)
			const worst = Math.max(Math.abs(t - 0), Math.abs(t - yUpper))
			ub += w * worst
		}
	}

	return ub > 0 ? ub : 1
}

const fitPenalty = (slots: number[], frozen: Inputs) => {
	const y = computeTotals(slots, frozen.maxBerries)
	const yUpper = frozen.maxBerries * MAX_COMPONENT
	let p = 0

	for (let j = 0; j < 5; j++) {
		const g = frozen.goals[j]
		if (!g || g.mode === "exact") continue

		const w = weightOf(g)

		if (g.mode === "approx") p += w * Math.abs(y[j] - (g.target ?? 0))
		else if (g.mode === "min" || g.mode === "ignore") p += w * y[j]
		else if (g.mode === "max") p += w * (yUpper - y[j])
	}

	return p
}

const usedNorm = (used: number, Kmax: number) => {
	const denom = Kmax - KMIN
	if (denom <= 0) return 0
	return (used - KMIN) / denom
}

type Scored = {
	slots: number[]
	key: string
	fit: number
	fitNorm: number
	used: number
	usedNorm: number
	combined: number
}

const sortScored = (a: Scored, b: Scored) => {
	if (a.combined < b.combined) return -1
	if (a.combined > b.combined) return 1

	if (a.fit < b.fit) return -1
	if (a.fit > b.fit) return 1

	if (a.used < b.used) return -1
	if (a.used > b.used) return 1

	return a.key < b.key ? -1 : a.key > b.key ? 1 : 0
}

const cloneInputs = (inputs: Inputs): Inputs => {
	const caps = inputs.inventoryCaps ? inputs.inventoryCaps.slice() : undefined
	const goals = inputs.goals ? inputs.goals.map((g) => ({ ...g } as any)) : []
	return {
		maxBerries: inputs.maxBerries,
		inventoryEnabled: inputs.inventoryEnabled,
		inventoryCaps: caps,
		goals: goals as any,
		maxTimeout: inputs.maxTimeout,
		favorFewerVectors: inputs.favorFewerVectors,
		maxHeapSize: inputs.maxHeapSize,
		sliceMs: inputs.sliceMs,
		maxNodes: inputs.maxNodes,
		greedyPerSlice: inputs.greedyPerSlice
	}
}

type SpeedSample = { t: number; expanded: number }
const SPEED_WINDOW_MS = 1000
const ZERO_GRACE_MS = 400

export const useSolutionRunner = (inputs: Inputs) => {
	const workerRef = useRef<Worker | null>(null)
	const seenRef = useRef<Set<string>>(new Set())
	const scoredRef = useRef<Scored[]>([])

	const runIdRef = useRef(0)
	const playingRef = useRef(false)

	// staged inputs: always reflect latest UI values, but NOT used by solver until we freeze
	const stagedRef = useRef<Inputs>(inputs)
	stagedRef.current = inputs

	// frozen settings: ONLY set on first play (after reset) and then never changes until reset()
	const frozenRef = useRef<Inputs | null>(null)

	const inFlightAbortRef = useRef<AbortController | null>(null)
	const lastSolutionTRef = useRef(0)

	const [solutions, setSolutions] = useState<number[][]>([])
	const [playing, setPlaying] = useState(false)
	const [done, setDone] = useState(false)

	const [stats, setStats] = useState<WorkerStats | null>(null)
	const [speed, setSpeed] = useState(0)

	const speedSamplesRef = useRef<SpeedSample[]>([])
	const lastProgressTRef = useRef(0)
	const lastSpeedRef = useRef(0)

	const updateSpeed = (expanded: number) => {
		const now = performance.now()

		const samples = speedSamplesRef.current
		samples.push({ t: now, expanded })

		while (samples.length > 1 && now - samples[0].t > SPEED_WINDOW_MS) {
			samples.shift()
		}

		const first = samples[0]
		const last = samples[samples.length - 1]

		const dExp = last.expanded - first.expanded
		const dT = last.t - first.t

		if (dExp > 0 && dT > 0) {
			const s = (dExp * 1000) / dT
			lastSpeedRef.current = s
			lastProgressTRef.current = now
			setSpeed(s)
			return
		}

		if (now - lastProgressTRef.current <= ZERO_GRACE_MS) {
			setSpeed(lastSpeedRef.current)
			return
		}

		lastSpeedRef.current = 0
		setSpeed(0)
	}

	const createWorker = () => createVectorSolverWorker()

	useEffect(() => {
		if (!workerRef.current) workerRef.current = createWorker()

		return () => {
			const w = workerRef.current
			if (!w) return

			inFlightAbortRef.current?.abort()
			inFlightAbortRef.current = null

			w.postMessage({ type: "cancel" })
			w.terminate()
			workerRef.current = null
		}
	}, [])

	const abortInFlight = () => {
		inFlightAbortRef.current?.abort()
		inFlightAbortRef.current = null
	}

	const pause = () => {
		const w = workerRef.current
		if (!w) return

		abortInFlight()
		w.postMessage({ type: "cancel" })

		playingRef.current = false
		setPlaying(false)

		runIdRef.current += 1
	}

	const reset = () => {
		const wOld = workerRef.current
		if (!wOld) return

		abortInFlight()
		wOld.postMessage({ type: "cancel" })

		// hard reset: new worker = guaranteed memory flush for worker heap
		wOld.terminate()
		workerRef.current = createWorker()

		seenRef.current = new Set()
		scoredRef.current = []

		playingRef.current = false
		setPlaying(false)
		setDone(false)
		setSolutions([])

		setStats(null)
		setSpeed(0)

		speedSamplesRef.current = []
		lastProgressTRef.current = 0
		lastSpeedRef.current = 0
		lastSolutionTRef.current = 0

		// IMPORTANT: do NOT freeze here. Clear it so next play() captures latest UI values.
		frozenRef.current = null

		runIdRef.current += 1
	}

	const flushMs = 150
	const lastFlushRef = useRef(0)
	const dirtyRef = useRef(false)

	const flushSolutions = () => {
		const arr = scoredRef.current
		arr.sort(sortScored)

		const next: number[][] = []
		for (let i = 0; i < arr.length; i++) next.push(arr[i].slots)

		setSolutions(next)
		dirtyRef.current = false
	}

	const maybeFlush = async () => {
		if (!dirtyRef.current) return

		const now = performance.now()
		if (now - lastFlushRef.current < flushMs) return

		lastFlushRef.current = now
		flushSolutions()

		await new Promise(requestAnimationFrame)
	}

	const play = () => {
		const w = workerRef.current
		if (!w) return
		if (playingRef.current) return

		// Freeze inputs ONLY on first play (after reset) using the latest staged UI values
		if (!frozenRef.current) frozenRef.current = cloneInputs(stagedRef.current)

		const frozen = frozenRef.current
		if (!frozen) return

		playingRef.current = true
		setPlaying(true)
		setDone(false)

		const runId = runIdRef.current + 1
		runIdRef.current = runId

		const fitUb = fitUpperBound(frozen)
		lastSolutionTRef.current = performance.now()

		const lambdaFrozen = clamp01(frozen.favorFewerVectors)

		const cfg = {
			vectors: berryVectors,
			Kmin: KMIN,
			Kmax: frozen.maxBerries,
			inventoryEnabled: frozen.inventoryEnabled,
			inventoryCaps: frozen.inventoryEnabled ? frozen.inventoryCaps : undefined,
			goals: frozen.goals,
			batchSize: 1,
			favorFewerVectors: lambdaFrozen,
			options: {
				timeout: Infinity,
				sliceMs: typeof frozen.sliceMs === "number" ? frozen.sliceMs : 25,
				maxNodes: typeof frozen.maxNodes === "number" ? frozen.maxNodes : 200000,
				greedyPerSlice: typeof frozen.greedyPerSlice === "number" ? frozen.greedyPerSlice : 2,
				maxHeapSize:
					frozen.maxHeapSize === Infinity
						? Infinity
						: typeof frozen.maxHeapSize === "number"
							? frozen.maxHeapSize
							: Infinity
			}
		}

			; (async () => {
				while (true) {
					if (!playingRef.current) return
					if (runIdRef.current !== runId) return

					const controller = new AbortController()
					inFlightAbortRef.current = controller

					let batch: SolveBatchReply
					try {
						batch = await solveBatch(w, cfg, controller.signal, 10000)
					} catch (e: any) {
						if (e?.name === "AbortError") return

						playingRef.current = false
						setPlaying(false)
						setDone(true)
						return
					} finally {
						if (inFlightAbortRef.current === controller) inFlightAbortRef.current = null
					}

					if (!playingRef.current) return
					if (runIdRef.current !== runId) return

					const results = batch.results
					const status = batch.status
					const st = batch.stats

					if (st) {
						setStats(st)
						updateSpeed(st.expanded)
					}

					if (status === "cancelled") {
						playingRef.current = false
						setPlaying(false)
						setDone(false)
						return
					}

					const now = performance.now()

					if (results && results.length > 0) {
						const slots = results[0]
						const key = slots.join(",")

						if (seenRef.current.has(key)) {
							await maybeFlush()
							continue
						}

						seenRef.current.add(key)
						lastSolutionTRef.current = now

						const fit = fitPenalty(slots, frozen)
						const fitNorm = fitUb > 0 ? fit / fitUb : 0

						const used = countUsed(slots)
						const uNorm = usedNorm(used, frozen.maxBerries)

						const combined = (1 - lambdaFrozen) * fitNorm + lambdaFrozen * uNorm

						scoredRef.current.push({ slots, key, fit, fitNorm, used, usedNorm: uNorm, combined })
						dirtyRef.current = true

						await maybeFlush()
						continue
					}

					await maybeFlush()

					if (status === "exhausted") {
						if (dirtyRef.current) flushSolutions()

						playingRef.current = false
						setPlaying(false)
						setDone(true)
						return
					}

					if (frozen.maxTimeout !== Infinity) {
						const elapsed = now - lastSolutionTRef.current
						if (elapsed >= frozen.maxTimeout) {
							if (dirtyRef.current) flushSolutions()

							playingRef.current = false
							setPlaying(false)
							setDone(true)
							return
						}
					}
				}
			})()
	}

	return { solutions, playing, done, play, pause, reset, stats, speed }
}
